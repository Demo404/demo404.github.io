[{"title":"Redis学习 ｜ 一、Redis相关知识","url":"/2025/12/26/Redis%E5%AD%A6%E4%B9%A0-%EF%BD%9C-%E4%B8%80%E3%80%81Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/","content":"Redis相关知识和数据类型🍃 Redis一些基础1、默认有16个数据库，出事默认使用0号数据库。2、使用命令 select &lt;dbid&gt; 切换数据库，如 select 8 切换到8号数据库。3、dbsize 查看当前数据库的key的数量。4、flushdb 清空当前数据库的缓存数据。5、flushall 清空所有数据库的缓存数据。6、相对于 memcached，Redis 支持的数据类型更加丰富，内存中的数据也支持持久化。\nRedis为单线程+多路IO复用技术多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入了多个文件描述符，如果有一个文件描述符就绪则返回，否则阻塞直到超时。等到就绪状态后可以在一个线程中进行真正的操作，也可以启用线程池。\n⚙️ Redis中key键操作\nkeys * 查看当前数据库中的key\nexists &lt;key&gt; 判断key是否存在  127.0.0.1:6379&gt; exists k1(integer) 0127.0.0.1:6379&gt; exists sys_dict:sys_user_sex(integer) 1\ntype &lt;key&gt; 判断key的类型  127.0.0.1:6379&gt; type sys_dict:sys_user_sexstring\ndel &lt;key&gt; 删除指定的key数据\nunlink &lt;key&gt; 根据value选择非阻塞删除（仅将key删除，数据会在后续异步删除）\nexpire &lt;key&gt; 10 为指定的key设置过期时间为10秒\nttl &lt;key&gt; 查看kay还有多久过期，-1表示不过期，-2表示已过期\ndbsize 查看当前数据库中key的数量\nselect &lt;dbid&gt; 切换数据库\n\nRedis中常见的数据类型有 list, set, hash, zset, string 五种。\n"},{"title":"人工智能服务AIService","url":"/2025/12/11/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%9C%8D%E5%8A%A1AIService/","content":"一、什么是AIServiceAIService使用面向动态代理和接口的方式完成程序的编写，更灵活的实现高级功能的配置。\n链Chain链是针对每个常见的用例都设置一条链，比如聊天机器人和检索增强生成等。链将底层多个组件组合起来并协调他们之间的交互。缺点：不够灵活\nAIService常见的处理操作1、为大语言模型格式化输入内容2、解析大预言模型的输出结果3、聊天记忆 chat memory4、工具 tools5、检索增强生成 RAG\n二、创建一个最简单的AIService1、通过模型注入创建AIService定义接口Assistent.java,包含一个方法chat()\npublic interface Assistent &#123;    String chat(String prompt);&#125;\n调用自定义的chat方法，使用OpenAiChatModel\n@SpringBootTest(classes = XiaozhiApp.class)public class AIServiceTest &#123;    @Autowired    private OpenAiChatModel openAiChatModel;    @Test    public void testAIService()&#123;        Assistent assistent = AiServices.create(Assistent.class, openAiChatModel);        String response = assistent.chat(&quot;请介绍一下你自己。&quot;);        System.out.println(&quot;AI Response: &quot; + response);    &#125;&#125;\n执行该测试程序，输出如下：\n2025-12-11T16:02:00.718+08:00 DEBUG 50590 --- [Http TaskRunner] okhttp3.internal.concurrent.TaskRunner   : Q10005 finished run in 240 µs: OkHttp ConnectionPoolAI Response: 你好！我是通义千问（Qwen），由阿里巴巴集团旗下的通义实验室自主研发的超大规模语言模型。我可以帮助你回答问题、创作文字，比如写故事、写公文、写邮件、写剧本、逻辑推理、编程等等，还能表达观点，玩游戏等。我支持多种语言，包括但不限于中文、英文、德语、法语、西班牙语等，能够满足国际化的使用需求。同时，我基于大量的互联网文本训练，具备广泛的知识和理解能力。如果你有任何问题或需要帮助，随时告诉我！😊\n通过使用@AIService注解使用@AiService注解来简化注入步骤，直接在接口上增加@AiService注解\n@AiServicepublic interface Assistent &#123;    String chat(String prompt);&#125;\n调用模型时不再注入模型到上下文中\n@Autowiredprivate Assistent assistent;@Testpublic void testAIServiceWithSpring()&#123;    String response = assistent.chat(&quot;请介绍一下我自己。&quot;);    System.out.println(&quot;AI Response: &quot; + response);&#125;\n此时如果上下文中有多个模型则会运行报错：Caused by: dev.langchain4j.service.IllegalConfigurationException: Conflict: multiple beans of type dev.langchain4j.model.chat.ChatLanguageModel are found: [ollamaChatModel, openAiChatModel]. Please specify which one you wish to wire in the @AiService annotation like this: @AiService(wiringMode = EXPLICIT, chatModel = &quot;&lt;beanName&gt;&quot;).,需要在@AiService中明确执行使用哪一个模型，修改接口如下:\n@AiService(wiringMode = EXPLICIT, chatModel = &quot;openAiChatModel&quot;)public interface Assistent &#123;    String chat(String prompt);&#125;\n再次重新运行则正常输出相应内容\n2025-12-11T16:01:08.799+08:00 DEBUG 50574 --- [Http TaskRunner] okhttp3.internal.concurrent.TaskRunner   : Q10005 finished run in 189 µs: OkHttp ConnectionPoolAI Response: 你好！不过我还不太了解你，所以无法准确地介绍你。如果你愿意告诉我一些关于你的信息——比如你的兴趣爱好、职业、学习背景、所在地区，或者你希望别人怎么看待你——我很乐意根据你提供的内容，帮你写一段个性化的自我介绍！😊\n"},{"title":"MySQL学习 ｜ 一、MySQL的基本概念和安装","url":"/2023/07/26/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%80%E3%80%81MySQL%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E5%AE%89%E8%A3%85/","content":"一、数据库相关的概念数据库（DB）：存储数据的仓库，数据是有组织的进行存储。\n数据库管理系统（DBMS）：操作和管理数据库的大型软件。‍‍‍‍‍‍‍\nSQL：操作关系型数据库的编程语言，定义了一套操作关系型数据库的统一标准。  \n​\t\t  \n二、主流的数据库管理系统1、Oracle：oracle公司研发，大型且收费。\n2、MySQL：小型，有免费有收费。‍\n3、PostgreSQL：中小型数据库，免费。\n4、SQLite：嵌入性数据库，安卓系统采用SQLite。\n. . . . . .‍‍‍\n​\t\t\n三、MySQL的安装和启动‍‍‍版本：\n社区版（MySQL Community Server）\n免费，MySQL不提供任何技术支持。\n\n商业版（MySQL Enterprise Edition）‍‍\n收费，可试用，MySQL提供技术支持。\n\n\n下载地址：https://dev.mysql.com/downloads/ 或者 https://www.mysql.com/ 依次如下点击进行下载。\n\n下拉页面找到download\n\n下载 MySQL Community Server 版（根据自身情况选择）\n\n然后选择对应的版本下载\n\n最后一步可以不用登录和注册。\n\n安装步骤：1、上传下载的安装包到服务器的 &#x2F;usr&#x2F;local 目录下‍\n2、使用 tar 命令解压下载的安装包‍\n tar -xvf mysql-8.0.33-linux-glibc2.12-x86_64.tar.xz参数说明：-x：解压缩压缩档案的参数-v：压缩的过程中显示档案-f：置顶文档名，在f后面立即接文件名，不能再加参数\n\n3、重命名解压后的文件夹\nmv mysql-8.0.33-linux-glibc2.12-x86_64 mysql\n\n4、修改MySQL的配置文件如下\nvim /etc/my.cnf\n# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html[mysqld]skip-name-resolvecharacter_set_server=utf8init_connect=&#x27;SET NAMES utf8&#x27;## Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M## Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin## Remove leading # to set options mainly useful for reporting servers.# The server defaults are faster for transactions and fast SELECTs.# Adjust sizes as needed, experiment to find the optimal values.# join_buffer_size = 128M# sort_buffer_size = 2M# read_rnd_buffer_size = 2Mdatadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sock# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0log-error=/var/log/mysqld.logpid-file=/var/run/mysqld/mysqld.pid#最大连接数max_connections=1000\n 然后 :wq 退出编辑。‍‍‍‍‍‍‍\n5、新建用户和用户组‍\ncd /usr/local/mysql/groupadd mysql               # 创建用户组useradd -r -g mysql mysql    # 创建用户并且指定用户组chown -R mysql:mysql ./      # 修改当前文件的归属用户和用户组\n\n6、初始化数据库，分别执行如下命令\ncd /usr/local/mysql/mkdir ./data./bin/mysqld --user=mysql --basedir=/usr/local/mysql/ --datadir=/usr/local/mysql/data/ --initialize\n\n第三步命令如果报错：‍‍‍‍.&#x2F;bin&#x2F;mysqld: error while loading shared libraries: libaio.so.1: cannot open shared object file: No such file or directory 的话说明当前缺少了libaio.so.1库，执行如下命令安装libaio.so.1库。\nyum install -y libaio\n\n安装成功后再次执行第三条命令，出现如下界面则说明安装成功了，最后的初始化密码要记住。\n\n7、添加MySQL到系统服务中并且建立软连接‍\ncp -a ./support-files/mysql.server /etc/init.d/mysqlchmod +x /etc/init.d/mysqlchkconfig --add mysqlchkconfig --list mysql #检查是否生效\n\n\n建立软连接\nln -s /usr/local/mysql/bin/mysql /usr/bin\n\n8、启动并且登录MySQL\n执行 service mysql start 命令，出现 Success字样则说明启动成功。 \n\n登录MySQL‍\nmysql -u root -p\n\n\n回车然后输入刚才的初始化密码，输入时光标并不会有任何变化。  \n修改用户密码\nALTER USER &quot;root&quot;@&quot;localhost&quot; IDENTIFIED  BY &quot;你的新密码&quot;;FLUSH PRIVILEGES;  #配置生效\n\n\n修改如下配置，使得root用户可以远程连接。‍‍\nuse mysql;  update user set host=&#x27;%&#x27; where user =&#x27;root&#x27;;FLUSH PRIVILEGES;    #配置生效\n\n​\t\t\n四、MySQL的数据模型关系型数据库（RDBMS）概念：建立在关系型模型基础上，由多张相互连接的二维表组成的数据库。\n特点：&emsp;&emsp; - 1、使用表结构存储。格式统一便于维护。&emsp;&emsp; - 2、使用SQL语言操作，标准统一使用方便。\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 七、SQL语言中的约束","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%83%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%A6%E6%9D%9F/","content":"1、概念  \n约束是作用于表中字段上的规则，用于限制存储在表中的数据。‍\n2、目的‍\n保证数据库中数据的正确性、有效性和完整性。‍‍‍‍\n3、分类‍\n\n\n\n约束\n描述\n关键字\n\n\n\n非空约束\n限制该字段的数据不能为null\nNOT　NULL\n\n\n唯一约束\n保证该字段所有的值都是唯一不重复的\nUNIQUE\n\n\n主键约束\n主键是一行数据的唯一标识，要求非空且唯一\nPRIMARY KEY\n\n\n默认约束\n保存数据时如果未指定该字段的值则使用默认约束\nDEFAULT\n\n\n检查约束（8.0.16版本之后）\n保证字段值满足某一个条件\nCHECK\n\n\n外键约束\n用来将两张表的数据之间建立连接，保证数据的一致性和完整性\nFOREIGN KEY\n\n\n4、外键约束\n创建外键\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名);\n\n删除外键  \nALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\n\n\n\n5、外键的删除&#x2F;更新行为\n\n\n\n行为\n说明\n\n\n\nNO ACTION\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与RESTRICT一致）\n\n\nRESTRICT\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。（与NO ACTION一致）\n\n\nCASCADE\n当在父表中更新&#x2F;删除记录时，首先检查该记录是否有对应外键，如果有删除&#x2F;更新外键在子表中的记录。（与NO ACTION一致）\n\n\nSET NULL\n当在父表中删除记录时，首先检查该记录是否有对应外键，如果有则将子表中该外键的值置为null。\n\n\nSET　DEFAULT\n父表有变更时，字表将外键列设置为一个默认值。（InnoDB引擎不支持）\n\n\n语法：\nALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名) ON UPDATE CASCADE ON DELETE CASCADE;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 三、SQL语言中DML语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B8%89%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDML%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DML：数据操作语言，用来对数据库表中的数据进行增删改操作。\n\n\n添加语句（INSERT）\n给指定字段添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2);\n\n给所有的字段添加数据：‍‍‍‍\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n);\n\n批量添加数据：\nINSERT INTO 表名(字段1, 字段2) VALUES(值1, 值2), (值1, 值2)(值1, 值2);\nINSERT INTO 表名 VALUES(值1, 值2 ... 值n), (值1, 值2 ... 值n), (值1, 值2 ... 值n);\n\n添加语句注意的事项：  \n&emsp;&emsp;&emsp;&emsp;1、插入数据时，指定的字段顺序要和值的顺序一一对应。\n&emsp;&emsp;&emsp;&emsp;2、字符串和日期类型应该包裹在引号中。‍‍\n&emsp;&emsp;&emsp;&emsp;3、输入的数据大小应该在字段规定范围内。\n\n\n修改语句（UPDATE）\n修改表中的数据:\nUPDATE 表名 SET 字段1=值1, 字段2=值2 [WHERE 条件];\n\n修改语句的条件没有时会更新整个表的数据。\n\n\n删除语句（DELETE）  \n删除表中的数据:\nDELETE FROM 表名 [WHERE 条件];\n\n删除语句的条件没有时会删除整个表的数据。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 九、SQL语言中的事物","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%B9%9D%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E4%BA%8B%E7%89%A9/","content":"一、事物的简介‍‍1、什么是事物\n事物是一组操作的集合，它是一个不可分割的工作单元，事物会把所有的操作作为一个整体一起向系统提交或者撤销操作请求，即这些操作要么全部同时成功，要么同时失败。\nMySQL数据库是自动提交事物的。‍‍‍‍\n  \n\n二、事物的操作1、查看、设置事物的提交方式\nSELECT @@AUTOCOMMIT;SET @@AUTOCOMMIT = 0;    (0: 手动提交；1:自动提交)\n\n2、提交事物‍\nCOMMIT;\n\n\n3、回滚事物\nROLLBACK;\n\n4、开启事物\nSTART TRANSACTION;或者BEGIN;\n\n  \n\n三、事物的四大特性 ACID‍‍‍1、原子性（Atomicity）：事物是不可分割的最小操作单元，要么全部成功，要么全部失败。‍‍\n2、一致性（Consistency）：事物完成时，数据的总量保持不变，必须使所有的数据都保持一致的状态。‍\n3、隔离性（Isolation）：数据库提供的隔离机制，保证事物在不受外部并发操作影响的环境下独立运行（A事物的操作不会影响正在进行的B事物）。\n4、持久性（Durability）：事物一旦提交或者回滚，他对数据库中的改变都是永久的。\n\n\n四、并发事物产生的问题‍1、脏读：一个事物读取到了另一个事物没提交的数据。‍‍\n2、不可重复读：一条事物先后执行同样的SQL，但是两次读取的数据不同（同一行数据每次查询不同）。‍‍‍‍‍\n3、幻读：一个事物在执行查询时，每次查询到的数据行数不一致（某一行数据一会存在一会又不存在）。‍\n\n\n五、事物的隔离级别\n\n\n隔离界别\n脏读\n不可重复读\n幻读\n\n\n\nRead Uncommitted\n✔️\n✔️\n✔️\n\n\nRead Committed\n✖️\n✔️\n✔️\n\n\nRepeatable Read\n✖️\n✖️\n✔️\n\n\nSerializable\n✖️\n✖️\n✖️\n\n\n事物的隔离界别越高，数据越安全，但是性能越低。\n查看事物的隔离级别\nSELECT @@TRANSACTION_ISOLATION;\n\n设置事物的隔离级别\nSET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZATION &#125;;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 二、SQL分类以及DDL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%8C%E3%80%81SQL%E5%88%86%E7%B1%BB%E4%BB%A5%E5%8F%8ADDL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"一、SQL的分类‍DDL（Date Definiition Lanhuage）：数据定义语言，用来定义数据库对象（数据库、表、字段等）。 create table 表名;\nDML（Data Manipulation Language）：数据操作语言，用来对数据库中的数据进行增删改查。 alter table 表名 add 字段名 类型(长度);\nDQL（Data Query Language）：数据查询语言，用来查询数据库中表里面的数据。\nselect * from 表名;\n\nDCL（Data Control Language）：数据控住语言，用来创建用户，控制用户对数据库的访问权限。‍\ngrant all privileges on *.* to &#x27;XXX&#x27;@&#x27;%&#x27; identified by &#x27;XXX&#x27; with grant option;\n\n\n\n二、DDL在数据库上的操作查询所有数据库: \nSHOW DATABASES;\n查询当前数据库：  \nSHOW DATABASE();\n 创建数据库：  \nCREATE DATABASE [IF NOT EXISTS] 库名 [DEFAULT CHARSET utf8mb4];\n 删除数据库：‍‍‍‍‍‍‍‍\nDROP DATABASE [IF NOT EXISTS] 库名;\n 使用数据库：\nUSE 库名;\n\n\n\n三、DDL在表上操作查询当前数据库中的所有表：\nSHOW TABLES;\n查询表结构（不会展示字段注释）：  \nDESC 表名;\n查询表的创建语句：\nSHOW CREATE TABLE 表名;\n 创建表：  \ncreate table 表名(    字段1 字段1类型 [comment 字段1注释],    字段2 字段2类型 [comment 字段2注释],    字段3 字段3类型 [comment 字段3注释],    ......    字段n 字段n类型 [comment 字段n注释])[comment 表注释];\n 添加字段：\nALTER TABLE 表名 ADD 字段名 类型(长度);\n 修改字段的数据类型：\nALTER TABLE 表名 MODIFY 字段名 字段类型(长度);\n修改字段的名称和类型：‍‍\nALTER TABLE 表名 CHANGE 旧字段名 新字段名 字段类型(长度);\n 删除字段：\nALTER TABLE 表名 DROP 字段名;\n 修改表名称：\nALTER TABLE 表名 RENAME TO 新表名;\n删除表：‍‍‍‍\nDROP TABLE [IF EXISTS] 表名;TRUNCATE TABLE 表名;\n\nDROP：物理删除表结构加数据。‍‍‍‍TRUNCATE：物理删除表结构加数据后 重新创建表。\n\n\n四、DDL语句中的数据类型1、数值类型  \n\n\n\n类型\n大小\n描述\n\n\n\nTINYINT\n1 bytes\n小整数值\n\n\nSMALLINT\n2 bytes\n大整数值\n\n\nMEDIUMINT\n3 bytes\n大整数值\n\n\nINT 或者 INTEGER\n4 bytes\n大整数值\n\n\nBIGINT\n8 bytes\n极大整数值\n\n\nFLOAT\n4 bytes\n单精度浮点整数\n\n\nDOUBLE\n8 bytes\n双精度浮点整数\n\n\nDECIMAL\n\n小数[精确定点数，依赖于M（精度）和D（标度）]\n\n\n2、字符串类型‍‍‍‍‍‍\n\n\n\n类型\n大小\n描述\n\n\n\nCHAR\n0 - 255 bytes\n定长字符串\n\n\nVARCHAR\n0 - 65536 bytes\n变长字符串\n\n\nTINYBLOG\n0 - 255 bytes\n不超过255个字符的二进制数据\n\n\nTINYTEXT\n0 - 255 bytes\n短文本字符串\n\n\nBLOG\n0 - 65536 bytes\n二进制形式的长文本数据\n\n\nTEXT\n0 - 65536 bytes\n长文本数据\n\n\nMEDIUMBLOG\n0 - 16777215 bytes\n二进制形式的中等长度文本数据\n\n\nMEDIUMTEXT\n0 - 16777215 bytes\n中等长度文本数据\n\n\nLONGBLOG\n0 - 4294967295 bytes\n二进制形式的极大文本数据\n\n\nLONGTEXT\n0 - 4294967295 bytes\n极大文本数据\n\n\n&emsp;&emsp; char(10): 即使存储一个字符，剩下的使用空格占位，效率高。&emsp;&emsp; varchar(10): 存储一个字符，实际占用一个字符，效率低一点。   \n3、日期时间类型\n\n\n\n类型\n大小\n范围\n格式\n描述\n\n\n\nDATE\n3\n1000-01-01 至 9999-12-31\nYYYY-MM-DD\n日期值\n\n\nTIME\n3\n-838:59:59 至 838:59:59\nHH:MM:SS\n时间值或持续时间\n\n\nYEAR\n1\n1901 至 2155\nYYYY\n年份值\n\n\nDATETIME\n8\n1000-01-01 00:00:00 至 9999-12-31 23:59:59\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值\n\n\nTIMESTAMP\n4\n1970-01-01 00:00:01 至 2038-01-19 03:14:07\nYYYY-MM-DD HH:MM:SS\n混合日期和时间值，时间戳\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 五、SQL语言中DCL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E4%BA%94%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDCL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DCL：数据控制语言，用来管理数据库用户、数据库访问权限。\n一、DCL管理用户创建用户\nCRAETE USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED BY &#x27;密码&#x27;;\n\n主机:  localhost:当前主机；%:任意机器。‍‍‍‍‍‍\n查询用户\nSELECT * FROM USER;\n\n修改用户密码  \nALTER USER &#x27;用户名&#x27;@&#x27;主机&#x27; IDENTIFIED WITH mysql_native_password &#x27;密码&#x27;;\n\n删除用户  \nDROP USER &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n  \n\n二、DCL权限控制‍‍mysql中常用的权限列表‍‍‍‍‍‍‍\n\n\n\n权限\n说明\n\n\n\nALL, ALL PRIVILEGES\n所有权限\n\n\nSELECT\n查询数据\n\n\nINSERT\n插入数据\n\n\nUPDATE\n修改数据\n\n\nDELETE\n删除数据\n\n\nALTER\n修改表\n\n\nDROP\n删除数据库&#x2F;表&#x2F;视图\n\n\nCREATE\n创建数据库&#x2F;表\n\n\n查询权限\nSHOW GRANTS FOR &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n授予权限  \nGRANT 权限列表 ON 数据库.表名 TO &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n撤销权限  \nREVOKE 权限列表 ON 数据库.表名 FROM &#x27;用户名&#x27;@&#x27;主机&#x27;;\n\n‍‍‍\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 八、SQL语言中的多表关系","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AB%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%A1%A8%E5%85%B3%E7%B3%BB/","content":"笛卡尔积：笛卡尔积是指在数学中，两个集合A集合和B集合的所有组合情况（多表查询时需要消除无效的笛卡尔积）。\n多表查询的分类1、内连接（C表示部分）\n\n隐式内连接    SELECT * FROM 表1, 表2 WHERE 条件;显示内连接    SELECT * FROM 表1 [INNER]JOIN 表2 ON 条件;\n\n2、外连接\n\n左外连接表示A和C部分\nSELECT 字段 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;\n\n右外连接表示B和C部分  \nSELECT 字段 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;\n\n3、自连接\nSELECT 字段 FROM 表A 别名A JOIN 表A 别名B ON 条件;\n\n4、联合查询‍\n    多次查询的结果合并起来，形成一个新的查询结果集。多张表的列数和类型需要保持一致。\nSELECT 字段列表 FROM 表A...UNION [ALL] SELECT 字段列表 FROM 表B...\n\nUNION: 查询结果去重‍\nUNION ALL: 查询结果不会去重‍‍‍‍‍‍‍‍‍\n4、子查询\nSQL语句中嵌套SELECT语句，称为嵌套语句，又称子查询。‍‍‍‍\nSELECT * FROM t1 WHERE column1 = (SELECT column1 FROM t2);","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 六、SQL语言中函数","url":"/2023/08/01/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%85%AD%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%87%BD%E6%95%B0/","content":"函数：是指一段可以直接被另一段程序调用的程序或代码。\n一、字符串函数\n\n\n函数\n功能\n\n\n\nCONCAT(S1, S2, …, Sn)\n字符串拼接，将字符串S1，S2…Sn拼接成一个新字符串\n\n\nLOWER(str)\n将字符串str全部转为小写\n\n\nUPPER(str)\n将字符串str全部转为大写\n\n\nLPAD(str, n, pad)\n左填充，用字符串pad对str的左边进行填充，达到n个字段的长度\n\n\nRPAD(str, n, pad)\n右填充，用字符串pad对str的右边进行填充，达到n个字段的长度\n\n\nTRIM(str)\n去掉字符串头部和尾部的空格\n\n\nSUBSTRING(str, start, len)\n返回字符串str从start开始起的len个长度的字符串\n\n\n1、CONCAT函数\nSELECT CONCAT(&#x27;hello&#x27;, &#x27;mysql&#x27;);输出：hello mysql\n\n2、LOWER函数‍‍\nSELECT LOWER(&#x27;HELLO&#x27;);输出：hello\n\n3、UPPER函数\nSELECT UPPER(&#x27;hello&#x27;);输出：HELLO\n\n4、LPAD函数  \nSELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：---01\n\n5、RPAD函数\nSELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);输出：01---\n\n6、TRIM函数（只能去除两端的空格，不能去除中间的空格）\nSELECT TRIM(&#x27; Hello Trim &#x27;);输出：Hello Trim\n\n7、SUBSTRING\nSELECT SUBSTRING(&#x27;Hello MySQL&#x27;, 1, 5);输出：Hello\n\n  \n\n二、数值函数‍‍\n\n\n函数\n功能\n\n\n\nCEIL(x)\n向上取整\n\n\nFLOOR(x)\n向下取整\n\n\nMOD(x, y)\n返回x&#x2F;y的模\n\n\nRAND()\n返回0～1内的随机数\n\n\nROUND(x, y)\n求参数x的四舍五入的值，保留y位小数\n\n\n1、CEIL函数\nSELECT CEIL(1.6);    输出：1SELECT CEIL(1.1);    输出：1\n\n2、FLOOR函数\nSELECT FLOOR(1.6);    输出：2SELECT FLOOR(1.1);   输出：2\n\n3、MOD函数(求余数)  \nSELECT MOD(3, 4);   输出：3SELECT MOD(6, 4);    输出：2\n\n4、RAND  \nSELECT RAND();       输出：0～1之间的随机数\n\n5、ROUND‍\nSELECT ROUND(2.34, 2);     输出：2.34SELECT ROUND(1.236, 2);    输出：1.24\n\n  \n\n三、日期函数‍‍‍‍\n\n\n函数\n功能\n\n\n\nCURDATE()\n返回当前日期\n\n\nCURTIME()\n返回当前时间\n\n\nNOW()\n返回当前日期和时间\n\n\nYEAR(date)\n返回执行date的年份\n\n\nMONTH(date)\n返回指定date的月份\n\n\nDAY(date)\n返回指定date的日期\n\n\nDATE_ADD(date, INTERVAL expr type)\n返回一个日期&#x2F;时间加上一个时间间隔expr后的时间值\n\n\nDATEDIFF(date1, date2)\n返回起始时间date1和结束时间date2之间的天数\n\n\n1、CURDATE\nSELECT CURDATE();    输出：2023-07-13\n\n2、CURTIME\nSELECT CURTIME();    输出：08:37:26\n\n3、NOW\nSELECT NOW();        输出：2023-07-13 08:38:33\n\n4、YEAR、MONTH、DAY\nSELECT YEAR(NOW());      输出：2023SELECT YEAR(MONTH());    输出：7SELECT YEAR(DAY());      输出：13\n\n5、DATE_ADD\nSELECT DATE_ADD(NOW(), INTERVAL 70 DAY);输出：2023-09-21 08:40:13SELECT DATE_ADD(NOW(), INTERVAL -10 MONTH);输出：2022-09-13 08:40:13\n\n6、DATEDIFF(第一个时间减第二个时间)\nSELECT DATEDIFF(&#x27;2023-07-10&#x27;, &#x27;2023-07-01&#x27;);输出：9\n\n  \n\n四、流程控制函数‍‍\n\n\n函数\n功能\n\n\n\nIF(value, t, f)\n如果value为true则返回t，否则返回f。\n\n\nIFNULL(val1, val2)\n如果val1不为空则返回val1，否则返回val2。\n\n\nCASE WHEN [val1] THEN [res1] … ELSE [default] END\n如果val1为true则返回res1…否则返回默认值default。\n\n\nCASE [expr] WHEN [val1] THEN [res1] … ELSE [default] END\n如果表达式expr的值为val1则返回res1…否则返回默认值default。\n\n\n1、IF\nSELECT IF(true, &#x27;OK&#x27;, &#x27;Error&#x27;);    输出：OK\n\n2、IFNULL‍\nSELECT IFNULL(&#x27;OK&#x27;, &#x27;Default&#x27;);    输出：OKSELECT IFNULL(&#x27;&#x27;, &#x27;Default&#x27;);      输出：SELECT IFNULL(NULL, &#x27;Default&#x27;);    输出：Default\n\n3、CASE WHEN THEN ELSE END\n查询员工姓名和城市，如果城市是上海和北京返回一线城市，其他返回二线城市SELECT \tname, \tCASE work_address WHEN &#x27;上海&#x27; THEN &#x27;一线&#x27; WHEN &#x27;北京&#x27; THEN &#x27;一线&#x27; ELSE &#x27;二线&#x27; END FROM worker;","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十、数据库中的存储引擎","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"一、MySQL的体系结构‍\n连接层：最上层是一些客户端和链接服务，主要完成一些连接处理、授权认证以及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具备的操作权限。‍\n服务层：主要完成大多数的核心功能，如SQL接口，并完成查询的缓存，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能在这一层实现，如存储过程和视图等。‍‍‍‍‍‍‍‍‍\n引擎层：存储引擎真正的负责了MYSQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样就可以根据自己的需要来选择合适的存储引擎。‍\n存储层：主要是将数据存储在文件系统之上并完成与存储引擎的交互。‍‍‍‍\n  \n\n二、存储引擎的简介1、什么是存储引擎‍‍‍\n存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而非基于库的，所以存储引擎也可被称为表类型。‍‍‍‍\n2、查看数据库支持的存储引擎‍‍\nSHOW ENGINES;\n\n\n3、查看已创建表的存储引擎‍\nSHOW CREATE TABLE tb_wxuser;\n\n\n\n\n三、常见的存储引擎1、InnoDB存储引擎：InnoDB是一种兼顾可靠性和高性能的通用存储引擎，在MySQL5.5之后InnoDB是默认的存储引擎。\nInnoDB的特点：\n（1）、DML遵循ACID模型，支持事物。‍\n（2）、支持行及锁，提高并发访问性能。‍‍‍‍\n（3）、支持外键FOREIGN KEY约束，保证数据的完整性和正确性。‍‍‍\nInnoDB的文件存储：\nXXX.ibd:XXX代表的是数据库的表名，InnoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm，sdi）、数据和索引。‍‍‍\n参数：innodb_file_per_table &#x3D; ON 表示每一个表对应一个ibd存储文件，OFF表示共用一个ibd存储文件。‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\nInnoDB的存储结构：\n\n2、MyISAM存储引擎：MyISAM是MySQL早期的默认存储引擎。\nMyISAM引擎特点：  \n（1）：不支持事物、不支持外键。\n（2）：支持表锁但不支持行锁。\n（3）：访问速度较快。  \nMyISAM引擎的文件存储：\n\n3、Memory存储引擎：Memory引擎的表数据存储在内存中，容易受到硬件问题、断电等的影响，因此只能将这些表作为临时表或者缓存使用。\nMemory引擎特点：\n（1）、内存存放数据 。\n（2）、默认hash索引。\nMemory引擎文件存储：\nxxx.sdi: 存储表结构信息\n4、innoDB、MyISAM、Memory三者的区别\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十一、数据库中的索引","url":"/2023/08/02/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95/","content":"一、索引概述什么是索引‍‍?\n索引（index）是帮助MySQL高效获取数据的有序数据结构。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构之上实现高级查找算法，这种数据结构就是索引。‍‍‍‍‍‍‍‍\n索引的优点‍‍\n    1、提高了检索数据的效率。\n    2、通过索引列对数据进行排序，降低数据的排序成本。\n索引的缺点：\n    1、索引也要占用空间。\n    2、索引提高了查询效率的同时也降低了更新数据（INSERT、UPDATE…）的效率。‍‍‍‍‍‍\n\n\n二、索引的语法创建索引\nCREATE [UNIQUE | FULLTEXT | ] INDEX index_name ON table_name(index_col_name, ...);\n\n查看索引\nSHOW INDEX FROM table_name;\n\n删除索引\nDROP INDEX index_name ON table_name;\n\n\n三、索引结构MySQL的索引是在引擎层实现的，不同的存储引擎有不同的结构，主要包括下面几种：‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n\n\n索引结构\n描述\n\n\n\nB+Tree索引\n最常见的索引类型，大部分引擎都支持B+树索引。\n\n\nHash索引\n底层使用hash表实现的索引，不支持范围查询，只有精确匹配的列才有效。\n\n\nR-tree索引（空间索引）\n空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。\n\n\nFull-text（全文索引）\n是一种通过建立倒排索引，快速匹配文档的方式。类似于Lucene，Solr，ES。\n\n\n不同的索引在各个存储引擎中的支持情况：\n\n\n\n索引\nInnoDB\nMyISAM\nMemory\n\n\n\nB+Tree索引\n支持\n支持\n支持\n\n\nHash索引\n不支持\n不支持\n支持\n\n\nR-tree索引\n不支持\n支持\n不支持\n\n\nFull-text（全文索引）\n5.6版本之后支持\n支持\n不支持\n\n\n数据结构在线模拟：https://www.cs.usfca.edu/~galles/visualization/Algorithms.html\n1、Btree和Btree索引\n二叉树（大于祖先节点在右侧，小于祖先节点在左侧）\n\n二叉树的缺点‍‍‍\n(1)、顺序插入时会形成一个链表，查询性能大大降低。(2)、数据量较大的情况下层级较深，检索速度慢。‍‍‍‍‍‍‍‍‍‍‍\n红黑树（自平衡的二叉树）‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍‍\n\n红黑树的缺点：数据量较大的情况下层级较深，检索速度慢。\nB树（多路平衡二叉树）\n以一颗最大度数（max-degree）为5（5阶）的b-tree为例（每个节点最多可存储4个数据，5个指针）。‍‍\n树的度数指得是一个节点的子节点的个数。\n\n2、B+树和B+树索引‍‍‍‍\n以一棵最大度数为4的b+为例‍‍‍‍‍\n\n（1）、所有的数据都会在叶子结点出现\n（2）、叶子结点会形成一个单向列表\nMySQL中的B+树\n\nMySQL数据结构对经典的B+树进行了优化。在原有B+树基础之上增加了一个只下过相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高了区间访问的性能。  \n3、hash索引\n采用一定的hash算法，将键值转换成新的hash值，映射到对应到槽位上，然后存储到hash表中。‍‍‍‍‍‍‍‍\n如果两个（或多个）键值映射到同一个槽位上，他们就产生了hash冲突（也成hash碰撞），hash冲突可以通过链表来解决。‍\n‍\nHash索引的特点：\n（1）、hash索引只能用于对等比较（&#x3D;，in），不支持范围查询（between，&lt;， &gt;）。‍‍\n（2）、无法利用索引完成排序。‍\n（3）、查询效率高，通常只需要一次检索即可（hash冲突时会去查询链表），效率高于B+tree索引。‍‍‍‍‍\n思考：为什么InnoDB索引选择B+树而非二叉树或者红黑树或者B树？‍‍‍‍‍‍\n如果是顺序插入的话，二叉树会形成链表，导致树的层级较深，从而降低查找的效率，红黑树本质也是二叉树，也会有该问题。相对于二叉树，B+树层级更少，效率更高。‍‍‍‍‍‍‍\nB树非叶子结点也会存储数据，导致磁盘页上存放的数据变少，相同数据量的情况下，树的高度会增加，导致效率降低。B+树的叶子节点为双向链表，便于范围查询和排序。‍‍‍‍‍\nHash索引不支持范围查询和排序。‍‍‍‍‍\n  \n\n四、索引分类\n\n\n分类\n含义\n特点\n关键字\n\n\n\n主键索引\n针对于表中主键创建的索引\n默认自动创建，只有一个。\nPRIMARY\n\n\n唯一索引\n避免同一表中某数据列的值重复\n可以有多个\nUNIQUE\n\n\n常规索引\n快速定位特定数据\n可以有多个\n\n\n\n全文索引\n全文索引查找的是文本中的关键词，而不是比较索引中的值。\n可以有多个\nFULLTEXT\n\n\n在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：\n\n\n\n分类\n含义\n特点\n\n\n\n聚集索引（Clustered Index）\n将数据存储与索引放在了一起，索引结构的叶子结点保存了行数据。\n必须有，而且只有一个。\n\n\n二级索引（Secondary Index）\n将数据与索引分开存储，索引结构的叶子结点关联的是对应的主键。\n可以存在多个。\n\n\n聚集索引的选取规则：‍‍‍‍‍‍‍‍\n    1、如果存在主键，主键就是聚集索引。\n    2、如果不存在主键，将使用第一个唯一索引作为聚集索引。\n    3、如果表没有主键或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。‍‍\n聚集索引和二级索引的图示‍‍\n\n聚集索引叶子节点存储的是每一行的数据（row），二级索引每一个叶子结点存储的是对应行的id。  \n聚集索引和二级索引在查询中的执行过程：‍‍‍\n\n1、首先执行where条件后的查询，使用二级索引根据name拿到id。\n2、根据id到聚集索引查询行数据。（回表查询）\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十三、SQL性能优化","url":"/2023/08/25/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%B8%89%E3%80%81SQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","content":"一、插入数据优化批量插入单条数据频繁的插入会存在大量的IO和不停的与数据库建立连接。批量插入的数据建议在500～1000条，更多的话建议使用多个批量插入。手动提交事物MySQL默认的是自动提交事物，多条插入语句时会频繁的开启、提交事物。\n\nstart transaction;insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);insert into tb_user values(1, ‘tom’),(2, ‘jerry’),(3, ‘lacy’);commit;\n\n主键按顺序插入\n\n主键乱序插入 8 2 5 98 2 56 121 1 4 22主键顺序插入 2 3 7 23 46 144 145 400\n\n大批量数据插入如果一次性需要插入大量的数据，使用insert语句插入数据性能较低，此时可以使用MySQL数据库提供的load指令进行插入。\n\n#客户端连接服务器端时，加上参数 –local-infilemysql –local-infile -u root -p#设置全局参数local_infile为1，开启从本地加载文件导入数据的开关。set global local_infile &#x3D; 1;#执行load指令将准备好的数据加载到表结构中load data local infile ‘数据文件路径’ into table 表名 fields terminated by ‘,’ lines terminated by ‘\\n’;\n\n二、主键优化数据组织方式在innoDB存储引擎中，表中数据都是根据主键顺序存放的，这种存储方式的表称为索引组织表（index orgnized tab）IOT。页合并当删除一行数据时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的纪录达到MERGE_THRESHOLD（默认为页的50%），InnoDB就开始寻找最靠近的页（前或后）看看是否可以讲两个页合并以优化空间的使用。MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引的时候指定。主键设计原则1、满足业务需求的情况下，尽量降低主键的长度，因为二级索引存储的数据就是主键。2、插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。3、尽量不要使用UUID（会产生页分裂以及UUID长度较大，长度较大时加大了二级索引的大小，降低了查询效率）或其他自然主键，如身份证号。4、业务操作时避免对主键的修改。\n三、order by 优化两种排序方式：\n\nUseing filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。\n\nUseing index：通过有序索引顺序扫描直接返回有序数据，这种情况即为useing index，不需要额外排序，操作效率高。\n\n\n执行如下SQL：select id, age, phone from tb_user order by age, phone;，会产生FileSort排序。对表tb_user创建如下索引：create index inx_user_age_phone on tb_user(age, phone);，再次执行上述查询，FileSort消失，转而使用索引排序，提高了查询效率。\n紧接着再次执行如下查询：select id, age, phone from tb_user order by age asc, phone desc;，会发现分别使用了索引排序和文件内排序，这是因为创建索引时默认字段为升序排列，再创建一个索引create index inx_user_age_phone on tb_user(age asc, phone desc);，执行查询语句：select id, age, phone from tb_user order by age asc, phone desc;，会发现使用了索引。\nOrder By优化原则\n1、根据排序字段建立合适的索引，多字段排序时也遵循最左前缀法则。\n2、尽量使用覆盖索引。\n3、多个字段排序，有的升序有的降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。\n4、如果避免不了FileSort，大数据量排序时，可以适当增加排序缓冲区的大小sort_buffer_size(默认256k)。\nSHOW VARIABLES LIKE &#x27;sort_buffer_size&#x27;;\n\n\n四、group by 优化1、分组操作时可以通过索引来提高效率。\n2、分组操作时，索引的使用也得满足最左前缀法则。\n五、limit优化一个常见有非常头疼的问题是limit 2000000,10，此时MySQL排序前2000010条记录，仅仅返回2000000～2000010的记录，其他的记录则舍弃，查询时排序代价非常大。\n优化思路：一般分页查询时，通过创建覆盖索引能够比较好的提高性能，可以通过覆盖索引加子查询形式进行优化。\nexplain select * from tb_sku s, (select id from tb_sku order by id limit 2000000,10) a where a.id = s.id;\n\n\n六、count优化explain select count(*) from tb_user;\n\n\nMyISAM引擎把一个表的总行数存放在磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高。\nInnoDB引擎执行count(*)的时候，需要把数据一行一行的从引擎里面读取出来，然后累计计数。\n\n优化思路：目前针对count并没有特别好的优化方式，可以自己在内存中维护一个计数器。\ncount的几种用法：\n\ncount(主键)\nInnoDB引擎会遍历整张表，把每一行的主键id都取出来返回给服务层，服务层拿到主键后，直接按行进行累加（主键不会为null）。\n\ncount(字段)\n没有not null 约束：InnoDB引擎会遍历整张表的每一行数据然后返回给服务层，服务层再判断是否为null，不为null时计数加1。\n有not null约束：InnoDB引擎会遍历整张表的每一行数据然后返回给服务层，服务层进行按行累加。\n\ncount(1)\nInnoDB遍历整张表但不取值，服务层对于返回的每一行都放一个数字“1”进去，直接按行进行累加。\n\ncount(*)\nInnoDB并不会把全部字段取出来，而是专门做了优化，服务层直接按行进行累加。\n\n\n按照效率排序：count(*) ≈ count(1) &gt; count(主键) &gt; count(字段) ，尽量使用count(*)。\n七、update优化（避免行锁升级为表锁）update tb_user set name = &#x27;zhang&#x27; where id = 1;\n\n此时为行锁，对并发无影响。\nupdate tb_user set name = &#x27;li&#x27; where name = &#x27;zhang&#x27;;\n\n如果name字段无有效的索引，此时将会把整个表锁住。\nInnoDB的行锁是针对索引加的锁（索引不能失效），不是针对记录加的锁，索引失效或者无索引的情况下会将行锁升级为表锁。\nupdate尽量使用主键进行更新。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十二、SQL性能分析和索引使用原则","url":"/2023/08/07/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%BA%8C%E3%80%81SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%92%8C%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99/","content":"一、查看SQL的执行频率通过SQL的执行频率可以确定当前数据库执行哪类操作比较多，然后做出对应的优化措施。\n通过如下命令可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT等操作的执行频次。\nSHOW GLOBAL STATUS LIKE &#x27;Com_______&#x27;\n\n\n\n\n二、慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。\nMySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：\n# 开启MySQL的慢日志查询开关slow_query_log=1# 设置慢日志的查询时间，SQL语句执行时间超过指定的值(如下超过10秒则为慢查询)，则会视为慢查询，记录慢查询日志。long_query_time=10\n\n配置完毕以后需重启MySQL服务，慢日志信息记录在文件：/var/lib/mysql/localhost-show.log中。\n查询慢日志查询是否开启，如下命令：\nSHOW VARIABLES like &#x27;slow_query_log&#x27;;\n\n输出Value值为：ON 则说明慢日志查询开启。\n\n\n三、show profiles命令在实际的业务中，有些SQL查询比较简单，但是查询占用的时间刚好小于慢日志记录设置的时间，导致这类慢SQL不能被捕捉到。\nshow profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够查看到当前MySQL是否支持profile操纵。\nSELECT @@have_profiling;\n\n输出值为：YES则说明当前数据库支持profile。\n默认profile是关闭的，可以通过命令开启GLOBAL或者SESSION级别的profiling。\nSET [GLOBAL | SESSION] profiling = 1;\n\nprofile相关的一些命令\n# 查看每一条SQL的耗时基本情况show profiles;# 查看指定query的SQL语句的各个阶段的耗时情况,query_id:上一步的idshow profile for query [query_id];# 查看指定SQL的CPU占用情况show profile cpu for query [query_id];\n\n\n\n四、explain命令EXPLAIN或者DESC命令用来获取MySQL是如何执行SELECT语句的信息，包括SELECT语句执行过程中表如何连接和连接顺序等信息。\n语法\n# 直接在select语句前面加上关键字 explain/descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;\n\nEXPLAIN展示的各个字段的含义：\n\n\n\n字段名\n含义\n\n\n\nid\n查询的序列号，表示查询中执行select字句或者是操作表的顺序。（id越大越先被执行，id相同时按照从上往下的顺序执行查询）\n\n\nselect_type\n表示select的类型，常见的取值有SIMPLE（简单表，即不使用表链接或者子查询）、PRIMARY（主查询，即外层查询）、UNION（UNION中的第二个或者后面的查询）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等。\n\n\ntype\n表示连接类型，性能由好到差为NULL、SYSTEM、CONST、EQ_REF、REF、RANGE、INDEX、ALL。\n\n\npossible_key\n显示可能用在这张表上的索引，一个或者多个。\n\n\nkey\n实际使用的索引，没有则为NULL。\n\n\nkey_length\n表示索引使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精度的情况下，长度越短越好。\n\n\nrows\nMySQL认为必须要执行查询的行数，在InnoDB引擎中是一个估算值，可能并不总是准确的。\n\n\nfiltered\n表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好。\n\n\nextra\n额外信息\n\n\nextra中显示的信息，MySQL版本不通则显示的不同。\n五、索引的使用规则以及失效场景最左前缀法则：如果索引了多列（联合索引），要遵守最佳左前缀法则。最左前缀法则是指查询从索引的最左列开始，并且不跳过索引中的列。如果跳过了索引中的某一列，索引将部分失效（跳过列后方的字段索引失效）；\n\nwhere条件后面列的顺序可以和索引中定义的顺序不一致。\n\nSQL提示：是优化数据库的一个重要手段，简单来说就是在SQL语句中加入一些人为的提示来达到优化操作的目的。\n\nuse index;  告诉数据库你应该使用哪一个索引（建议使用）\nSELECT 字段列表 FROM 表名 use index(index_name) WHERE 条件;\n\n\nignore index;  告诉数据库你不要使用哪一个索引\nSELECT 字段列表 FROM 表名 ignore index(index_name) WHERE 条件;\n\n\nforce index;  告诉数据库你必须要使用哪一个索引（强制使用）\nSELECT 字段列表 FROM 表名 force index(index_name) WHERE 条件;\n\n覆盖索引：尽量使用覆盖索引（查询使用了索引，并且查询的字段全部可以在索引中找到），避免使用SELECT *（极易出现回表查询）。\n\n现有如下表结构，分别对主键ID和字段name建立索引：\n\n\n\n\nID\nNAME\nGENDER\nCREATEDATE\n\n\n\n2\nArm\n1\n2023-08-22\n\n\n4\nLily\n1\n2023-08-01\n\n\n5\nRosy\n0\n2023-03-10\n\n\n8\nZoom\n1\n2023-11-09\n\n\n\n聚集索引（id）：\n\n\n\n辅助索引（name）：\n\n\n\n分别进行以下查询：\n\nSELECT * FROM tb_stu WHERE id = 2;走聚集索引，一次就可查询出数据。SELECT id, name FROM tb_stu WHERE name = &#x27;Arm&#x27;;走辅助索引即可查询出需要的所有数据（覆盖索引）。SELECT id, name, gender FROM tb_stu WHERE name = &#x27;Arm&#x27;;首先根据辅助索引查询，只能查询出name和id字段，然后再使用id字段去聚集索引中查询gender字段（回表查询）。\n\n\n思考：一张表有四个字段（id, name, password, status），由于数据量较大需要对以下SQL进行优化，该如何进行才是最优方案？\nSELECT id, name, password, status FROM tb_user WHERE name = &#x27;Tom&#x27;;\n\n方案1: 为字段name建立索引。\n如果只为name字段建立索引的话，查询回进行两次，首先走辅助索引查询出name和id，然后再使用主键索引根据id查询password和status字段，涉及到了回表操作。\n方案2: 为字段name和password以及status字段建立索引。\n此时where条件会使用建立的索引（最佳左前缀），并且根据索引就能查询出需要的数据，不需要回表等操作，因此性能最高。\n\n前缀索引：当字段类型为字符串（varchar，text）时，有时候需要索引很长的字符串（比如博客中的内容），只会让索引变得很大，查询时会浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀建立索引，这样可以大大减少索引空间进而提示查询效率。\n语法：\nCREATE INDEX index_name ON table_name(column(n));\t-- n:前缀长度\n\n如何决定前缀的长度：可以根据前缀的选择性来决定，而前缀的选择性是指不重复的索引值（基数）和数据总量的比值，选择性越高则查询效率越高，唯一索引的选择性为1，是最好的选择性，性能也是最高的。\n选择行计算：SELECT count (distinct email)/count(*) FROM tb_user;\t                -- 1SELECT count (distinct substring(email,1,4))/ count(*) FROM tb_user;\t-- 0.9876\n\n范围查询：联合索引中，出现范围查询（&gt;, &lt;）时，范围查询右侧的索引将失效。\n\n大于等于, 小于等于 不会使得索引失效，因此在业务允许的情况下尽量使用大于等于代替大于，用小于等于代替小于。\n\n索引列上运算：在索引列上进行计算操作将导致索引失效。\n字符串不加引号：使用字符串列时不加引号会导致索引失效（隐式转换）。\n模糊查询：如果仅是尾部进行模糊匹配索引不会失效，如果是头部进行模糊匹配则会失效。\n\nWHERE name like ‘%张三’；\t索引失效\nWHERE name like ‘张三%’；\t索引有效\n\nOR连接的条件：用or分隔开的条件，如果or前面的条件中的列有索引，而后面的列中没有索引，那么涉及到的索引都不会生效。or前后的条件都有索引时会生效。\n数据分布影响：如果MySQL评估使用索引比全表更慢时则不会使用索引。\n如果使用索引查出的数据量大于全表的数据量的1&#x2F;2，MySQL会使用全表扫描。\n\n对字段使用not null或者is not null时，MySQL也会评估是走索引还是全表扫描。\n\n\n\n六、索引的设计规则\n针对数据量较大且查询比较频繁的表建立索引。\n\n针对常作为查询条件（where）、排序（order）、分组（group by）操作的字段建立索引。\n\n尽量选择区分度较大的列作为索引，尽量选择唯一索引，区分度越高，使用索引的效率越高。\n\n如果是字符串类型的字段并且字段的长度较长，可以针对字段的特点建立前缀索引。\n\n尽量使用联合索引，减少单列索引，查询时联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。\n\n控制索引的数量，索引并不是越多越好，索引越多，维护索引的成本就越高，增删改的效率也会被影响。\n\n如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好的确定哪一个索引可最有效的用于查询。\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十五、MySQL中的锁","url":"/2023/08/30/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E4%BA%94%E3%80%81MySQL%E4%B8%AD%E7%9A%84%E9%94%81/","content":"一、锁的基本介绍介绍锁是计算机协调多个进程或者线程并发访问某一资源的机制，在数据库中，除了传统的计算资源（CPU、RAM、IO）争用外，数据也是一种供多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。分类MySQL中的锁，按照锁的粒度分为以下三类：1.全局锁：锁定数据库中的所有表2.表级锁：每次操作锁住整张表3.行级锁：每次操作锁住对应的行\n\n\n二、全局锁介绍全局锁就是对整个数据库实例加锁，加锁后整个实例处于只读状态，后续的DML的写语句，DDL语句，已经更新的操作的事物的提交语句都将被阻塞。最典型的使用场景就是全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。语法创建全局锁\nflush tables with read lock;\n解除全局锁\nunloak tables;\n数据库实例备份\nmysqldump -h 主机地址 -u用户名 -p密码 数据库实例名 &gt; 备份文件.sql\n特点数据库中的全局锁是一个比较重的操作，会存在以下问题：1.如果在主库上执行备份，那么备份期间都不能执行更新，整个业务停摆。2.如果在从库上备份，那么备份期间从库不能执行主库同步过来的二进制日志（binlog），导致主从延迟。在InnoDB引擎中，我们可以在备份时加行参数--single-transaction参数来完成不加锁的一致性数据备份。\nmysqldump --single-transaction -h 主机地址 -u用户名 -p密码 数据库实例名 &gt; 备份文件.sql\n\n三、表级锁介绍表级锁，每次操作都会锁住整张表。锁定力度大，发生锁冲突的概率高，并发度支持较低。应用在MyISAM，InnoDB，BDB等存储引擎中。对于表级锁，主要分为一下三类：    1.表锁    2.元数据锁（Meta Data Locl）MDL    3.意向锁表锁对于表锁，分为两类    1.表共享读锁（read lock）session1对表A加read lock，此时session1可以对表A执行查询操作但是不能执行修改操作，session2可以对表A执行查询操作但是不能执行修改操作。    2.表独占写锁（write lock）session1对表A加write lock，此时session1可以对表A执行查询操作和修改操作，session2即不能对表A执行查询操作页不能执行修改操作。语法1.加锁 lock tables 表名... read/write2.解锁 unlock tables / 断开客户端连接特点读锁不会阻塞客户端的读操作，但是会阻塞写操作。写锁会阻塞其他客户端的读写但不回阻塞当前加锁客户端的读写。元数据锁MDL加锁过程是系统自动控制的，无需显示调用，在访问一张表的时候会自动加上，MDL锁的作用是维护元数据的数据一致性，在表上有活动事物的时候，不可以对元数据进行写入操作。为了避免MDL和DDL的冲突，保证读写的正确性。在MySQL5.5中引入了MDL，当对一张表进行增删改操作的时候，加MDL读锁（共享）；当对一张表进行结构变更操作的时候，加MDL写锁（排他）。\n\n\n\n对应SQL\n锁类型\n说明\n\n\n\nlock table xxx read&#x2F;write\nSHARE_READ_ONLY、SHARE_NO_READ_WRITE\n\n\n\nselect、select … lock in share mode\nSHARE_READ\n与SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥\n\n\nInsert、update、delete、select … for update\nSHARE_WRITE\n与SHARE_READ、SHARE_WRITE兼容，与EXCLUSIVE互斥\n\n\nalter table …\nEXCLUSIVE\n与其他的MDL锁互斥\n\n\n意向锁为了避免DML在执行时，加的行锁和表锁出现冲突，在InnoDB中引入了意向锁，使得表锁不用检查每一行的数据是否加锁，使用意向锁来减少表锁的检查，从而提高效率。意向锁的分类：    1.意向共享锁（IS）：由语句 select ... lock in share mode; 添加，与表锁共享锁（read）兼容，与表锁排它锁（write）互斥。    2.意向排他锁（IX）：由语句 insert、update、delete、select ... for update 添加，与表锁共享锁（read）和排它锁（write）互斥，意向锁之间不回互斥。\n查看意向锁的加锁情况\nselect object_schema, object_name, index_name, lock_type, lock_data, lock_mode, lock_status from performance_schema.data_locks;\n行级锁每次操作都会锁住对应的行数据，锁的粒度最小，发生锁冲突的概率较低，并发度最高，应用在innoDB引擎中。行锁的分类：    InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项来加锁实现的，并不是对记录加锁。对于行级锁，主要分为以下三类：    1.行锁（Record Lock）：锁订单个行的记录到的锁，防止其他事物对该行数据进行update、delete等操作，在RC、RR隔离模式下都支持。    2.间隙锁（Gap Lock）：锁定索引记录间隙，确保索引记录间隙不变，防止其他事物在这个间隙insert，从而引起幻读，在RR模式下都支持。    3.临键锁（Next-key Lock）：行锁和间隙锁的组合，锁住数据的同时锁住数据前面的间隙（Gap），在RR模式下都支持。\nInnoDB实现了两种类型的行锁：    1.共享锁（S）：允许一个事物去读取一行，阻止其他事物获取相同数据集的排它锁。（当前事物读取数据时其他事物可以读取该行数据但是不能修改）    2.排它锁（X）：允许获取排它锁的事物更新数据，阻止其他事物获取相同数据集的共享锁和排它锁。（当前事物修改数据时，其他事物不能读取、不能修改当前行数据）\n\n\n\n锁类型\nS（共享锁）\nX（排它锁）\n\n\n\nS（共享锁）\n兼容\n冲突\n\n\nX（排它锁）\n冲突\n冲突\n\n\n常见的sql语句对行数据的加锁情况\n\n\n\nSQL\n行锁类型\n说明\n\n\n\nINSERT …\n排它锁\n自动加锁\n\n\nUPDATE …\n排它锁\n自动加锁\n\n\nDELETE …\n排它锁\n自动加锁\n\n\nSELECT (正常查询)\n不加任何锁\n\n\n\nSELECT … LOCK IN SHARE MODE\n共享锁\n手动在sql后面添加LOCK IN SHARE MODE\n\n\nSELECT … FOR UPDATE\n排它锁\n手动在sql后面添加FOR UPDATE\n\n\n\nInnoDB的行锁是针对索引添加的锁，不通过索引检索数据时，InnoDB将对表中的所有记录加锁，此时行锁升级为表锁\n\n现在有一张用户表，表结构如下：\ncreate table t_user_base_info(    id            varchar(32)      not null comment &#x27;id&#x27; primary key,    login_account varchar(50)      not null comment &#x27;登陆账号&#x27;,    password      varchar(50)      not null comment &#x27;登陆密码&#x27;,    username      varchar(255)     not null comment &#x27;用户名&#x27;,    user_type     int(2) default 1 not null comment &#x27;用户类型&#x27;);\n\n分别执行SQL语句\nUPDATE t_user_base_info set username = &#x27;张三&#x27; where id = &#x27;001&#x27;;加行锁，因为是根据主键更新。UPDATE t_user_base_info set username = &#x27;李四&#x27; where login_account = &#x27;admin&#x27;;行锁升级为表锁，因为login_account字段上面没有索引。\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十六、InnoDB存储引擎","url":"/2023/09/07/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E5%85%AD%E3%80%81InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/","content":"一、逻辑存储结构\n表空间（idb文件），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。\n段分为数据段、索引段、回滚段，InnoDB是索引组织表，数据段就是B+树的叶子结点，索引段为B+树的非叶子结点。段用来管理多个区（Extent）。\n区，表空间的单元结构，每个区的大小为1M。默认情况下，InnoDB存储引擎页大小为16K，即一个区中有64个连续页。\n页，是InnoDB存储引擎磁盘管理的最小存储单元，每一个页的大小默认为16K。为了保证数据的连续性，InnoDB存储引擎每次都会申请4～5个区。\nRow 行，InnoDB存储引擎是按行存放数据的。\n​\tTrx_id：每次对某条记录修改时，都会把事物id赋给trx_id隐藏列。\n​\tRoll point：每次对某条记录修改时，都会把旧的数据写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到修改前的信息。\n\n\n二、架构下面为InnoDB的架构图，其中左侧为内存结构，右侧为磁盘结构，中间为后台线程。\n\n1、内存结构Buffer Pool：缓冲池为主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（如果缓冲池中没有则从磁盘加载数据并且缓存），然后再以一定的频率刷新到磁盘，从而减少磁盘IO，加快处理速度。\n缓冲池以Page为单位，底层采用链表数据结构管理Page。根据状态可以将Page分为三类：\n​\t1、free page：空闲page，未被使用。\n​\t2、clean page：被使用的page，数据未被修改。\n​\t3、dirty page：脏页，被使用的page，数据被修改过，页中的数据与磁盘中的数据不一致。\nChange Buffer：更改缓冲区（针对于非唯一的二级索引），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而是从数据更改存储在更改缓冲区ChangeBuffer Pool中，在未来数据被读取时，将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。\nChange Buffer的意义是什么？\n与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次操作都去操作磁盘，则会引起非常大的磁盘IO，有了Change Buffer之后，就可以在缓冲池中进行合并操作，减少磁盘IO。\nAdaptive hash index：自适应hash索引，用于优化对Buffer Pool数据的查询。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到hash索引可以提升查询速度，则建立hash索引，称之为自适应hash索引。自适应hash索引无需人工干预，系统根据情况会自动生成。\n参数：adaptive_hash_index\nLog Buffer：日志缓冲区，用来保存要写入磁盘的log日志数据（包括redo log、undo log），默认大小为16M，日志缓冲区中的日志会定期刷新到磁盘中。如果需要更新、插入、删除许多行的事物，增大日志缓冲区的大小可以节省磁盘IO。\n参数：\ninnodb_log_buffer_size：缓冲区大小\nInnodb_flush_log_at_trx_commit：日志刷新到磁盘时机（1:日志在每次提交事物时写入磁盘文件；0:每秒将日志写入到磁盘文件一次；2:日志在每次提交事物后写入磁盘文件并且每秒刷新日志到磁盘文件）\n2、磁盘结构System Tablespace：系统表空间时更改缓冲区的存储区域。如果表是在系统表空间而不是每个表空间文件或者通用的表空间中创建的，他可能包含表和索引文件。（MySQL5.x版本还包括InnoDB数据字典和undo等）\n参数：innodb_data_file_path\nFile-pre-table Tablespace：每个表的文件表空间，包含单个InnoDB表的数据和索引，并存储在文件系统上的单个数据文件中。\n参数：innodb_file_pre_table\nGeneral Tablespace：通用表空间，需要通过CREATE TABLESPACE语法创建表空间，在创建表时可以指定该表空间。\n语法\nCREATE TABLESPACE xxx ADD DEFAULT &#x27;file_name&#x27; ENGINE = engine_name;\n\nCREATE TABLE xxx ... TABLESPACE tablespace_name;\n\nUndo Tablespace：撤销表空间，MySQl实例在初始化的时候会自动创建两个默认的undo表空间（初始大小16M），用于存储undo log。\nTemporary Tablespace：InnoDB使用回话临时表空间和全局临时表空间，存储用户创建的临时表等数据。\nDoublewrite Buffer File：双写缓冲区，InnoDB引擎将数据也从Buffer Pool刷新到磁盘前，先将数据页写入到双写缓冲区文件中，便于系统异常时恢复数据。\n相关文件：#ib_xxxxx_0.dblwr、#ib_xxxxx_1.dblwr\nRedo Log：重做日志，用来实现事物的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log），前者是在内存中，后者在磁盘中。当事物提交之后会把所有的修改信息都存储在该日志中，用于在刷新脏页到磁盘时发生错误后恢复数据使用。\n以循环方式写入重做日志文件，涉及两个文件：ib_logfile0、ib_logfile_1\n3、后台线程\nMaster Thread：核心后台进程，负责调度其他线程，还负责异步将缓冲池中的数据刷新到磁盘中，保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收。\n\nIO Thread：在InnoDB存储引擎中大量使用了AIO来处理IO请求，这样可以极大提高数据库的IO性能，而IO线程主页负责这些IO请求的回调。\n\n\n  执行命令show engine innodb status;可查看到相应的信息。\n  \n\n\n\n线程类型\n默认个数\n职责\n\n\n\nRead Thread\n4\n负责读操作\n\n\nWrite Thread\n4\n负责写操作\n\n\nLog Thread\n1\n负责将日志缓冲区刷新到磁盘\n\n\ninsert buffer thread\n1\n负责将写缓冲区内容刷新到磁盘\n\n\n\nPurge Thread：主要用于回收事物已经提交的undo log，在事物提交后，undo log可能就不用了，就用它来回收。\n\nPage Cleaner Thread：协助Master Thread刷新脏页到磁盘的线程，他可以减轻Master Thread的压力，减少阻塞。\n\n\n三、事物原理事物：是一组操作的集合，它是一个不可分割的工作单元，事物会把所有的操作视为一个整体一起向系统提交或者撤销操作请求，即这些操作要么全部成功，要么全部失败。\n特性：\n\n原子性（Atomicity）：事物是不可分割的最小单元，要么全部成功，要么全部失败。\n一致性（Consistency）：事物完成时，必须使所有的数据保持一致的状态。\n隔离性（Isolation）：数据库系统提供的隔离机制，保证事物在不受外部并发操作影响的独立环境下运行。\n持久性（Durability）：事物一旦提交或回滚，他对数据库中的数据的改变是永久的。\n\nredo log：重做日志，记录的是事物提交时数据页的物理修改，用来实现事物的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘上。当事物提交时会把所有的修改信息存储在该日志文件中，用于刷新脏页数据到磁盘时发生错误后进行数据恢复使用。\n\n客户端请求过来之后，首先去BufferPool中查找是否存在要操作的数据，如果不存在则从data文件中加载到BufferPool中然后操作，同时将操作记录到RedoLog Buffer中，RedoLog Buffer中的再写入到redo log file中，后台线程在刷新脏页数据到磁盘文件时如果出错可以借助redo log file进行恢复。\n为什么redo log buffer会直接写入磁盘而Buffer Pool时后台线程刷新到磁盘？因为redo log buffer写入到磁盘是顺序磁盘写入，效率要远高于Buffer Pool写入磁盘的随机磁盘写入。\nWAL(Write Ahead Log)预写日志，是数据库系统中常见的一种手段，用于保证数据操作的原子性和持久性。\nundo log：回滚日志，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC（多版本并发控制）。\nundo log和redo log记录物理日志不一样，记录的是逻辑日志。可以认为当客户端执行一条delete语句时，它会记录一条相应的insert语句，当执行一条update语句时，它会记录一条反向的update语句。当rollback时，就可以从undo log中读取相应的记录进行回滚操作。\nundo log销毁：undo log在事物执行时产生，在事物提交时并不会立即删除，因为这些日志还可能用于MVCC。\nundo log存储：undo log采用段的方式管理和记录，存储在rollback segement回滚段中，内部包含1024个undo log segement。\n\nMySQL中如何保证事物的四大特性？\n​\t\t\tRedoLog保证了事物的持久性\n​\t\t\tUndoLog保证了事物的原子性\n​\t\t\tRedoLog+UndoLog保证了事物的一致性\n​\t\t\tMVCC+锁保证了事物的隔离型\n\n\n\n\n\n四、MVCC1、mvcc中的一些基本概念当前读：读取的是记录的最新版本，读取时还要保证其他并发事物不能修改当前记录，会对读取的记录进行加锁。对于我们的日常操作，如select … lock in share mode（共享锁）, select … for update、update、insert、delete（排它锁）都是一种当前读。\n\n同时开启两个事物A和B，事物A对表中的id&#x3D;1的记录进行修改后并未提交，事物B查询时为修改前的数据，事物A提交事物后事物B查询时还是修改前的数据，此时将事物B的查询语句后增加lock in share mode可读取到id&#x3D;1的最新数据。\n\n快照读：简单的select查询就是快照读，读取的是记录数据的可见版本，有可能是历史数据，不会加锁，是非阻塞读。\n\nRead Committed：每次select都生成一个快照读。\nRepeatable Read：开启事物后第一个select语句才是快照读的地方。\nSerializable：快照读会退化为当前读。\n\nMVCC：多版本并发控制。指的是维护数据库的多个版本，使得读写操作没有冲突，快照读为MySQL实现，MVCC提供了一个非阻塞读功能，MVCC的具体实现还的依赖于数据库中的三个隐式字段、undo log、readView。\n2、隐藏字段\n创建用户表user时包含了三个字段，但实际在数据库中是6（或者5个）个字段。\n\n\n\n隐藏字段\n含义\n\n\n\nDB_TRX_ID\n最近修改事物的ID，记录插入这条数据或者最后一次修改这条数据的事物ID\n\n\nDB_ROLL_PTR\n回滚指针，记录这条记录的上一个版本，用于配合undo log，指向上一个版本。\n\n\nDB_ROW_ID\n隐藏主键，如果表结构没有指定主键，将会生成该隐藏主键\n\n\n\n在表空间文件中，使用命令 idb2sdi xxx.idb 命令可查看到完整的表信息，其中就包含DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID这三个字段。\n\n3、undo log\n不同事物或相同事物对同一记录进行修改，会导致该纪录的undo log会生成一条记录版本链表，链表的头部是最新的旧记录，链表的尾部是最早的旧记录。\n4、readViewReadVIew（读视图）是快照读SQL执行时MVCC读取数据的依据，记录并且维护系统当前活跃的事物（未提交）ID。\nReadVIew中包含了四个核心字段\n\n\n\n字段\n含义\n\n\n\nm_ids\n当前活跃的事物ID集合\n\n\nmin_trx_id\n最小活跃事物ID\n\n\nmax_trx_id\n预分配事物ID，当前最大事物ID+1（因为事物ID是自增的）\n\n\ncreator_trx_id\nReadVIew创建者的事物ID\n\n\n\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 十四、SQL中的视图","url":"/2023/08/28/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%8D%81%E5%9B%9B%E3%80%81SQL%E4%B8%AD%E7%9A%84%E8%A7%86%E5%9B%BE/","content":"一、视图的基本介绍和语法定义视图(View): 是一种虚拟存在的表，视图中的数据并不是真实存在的，行和列数据来自定义视图的查询中使用的表，并且是在使用时图时动态生成。通俗讲，视图只保存了查询数据的SQL，不保存查询结果，所以我们创建视图的时候主要工作就落在了创建这条SQL查询语句上。\n语法\n创建视图CRAETE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];\n查看创建视图语句SHOW CREATE VIEW 视图名称;查看视图数据SELECT 字段列表 FROM 视图名称 [WHERE ...];\n修改视图方式一：CRAETE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];视图二：ALTER 视图名称[(列名列表)] AS SELECT语句 [WITH [CASCADED | LOCAL] CHECK OPTION];\n删除视图DROP VIEW [IF EXISTS] 视图名称, [视图名称,]...\n\n\n二、视图中的检查选项当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查每个正在更改的行，例如插入，更新，删除，已使其符合视图的定义。MySQl允许基于另一个视图创建视图，它会依赖检查视图中的规则以保持一致性。WITH CASCADED CHECK OPTION   检查选项会传递需要满足当前视图的条件。并且对于所有底部视图的条件，也需要一并满足，哪怕底部视图没有定义with check option语句。\n\n不指定约束类型时，默认为cascaded约束，with check option &#x3D; with cascaded check option。\n\n创建视图 \ncreate or replace view stu_v_1 as select id, name from student where id &gt;= 10;\n执行以下插入语句均不会报错，因为当前视图没有检查选项。\ninsert into stu_v_1 values(8, &#x27;tom&#x27;);insert into stu_v_1 values(18, &#x27;jerry&#x27;);\n重新创建视图，指定约束条件\ncreate or replcae view stu_v_2 as select id, name from stu_v_1 where id &lt;= 20 with cascaded check option;\n再次执行以下插入语句，第一条语句会报错，因为stu_v_1要求id&gt;&#x3D;10,但是第二条语句不会报错。\ninsert into stu_v_2 values(8, &#x27;tom&#x27;);insert into stu_v_2 values(18, &#x27;jerry&#x27;);\nWITH LOCAL CHECK OPTION    检查选项不会传递需要满足当前视图的条件。对于底部视图，也是先看是否有指定的with check option语句，有的话对应处理，无则不需要满足底部视图的条件。创建视图 \ncreate or replcae view stu_v_3 as select id, name from student where id &gt;= 10;\n执行以下插入语句均不会报错，因为当前视图没有检查选项。\ninsert into stu_v_1 values(8, &#x27;tom&#x27;);insert into stu_v_1 values(18, &#x27;jerry&#x27;);\n重新创建视图，指定约束条件\ncreate or replcae view stu_v_4 as select id, name from stu_v_3 where id &lt;= 20 with local check option;\n再次执行以下插入语句，都不会报错，因为stu_v_3上没有check option校验，它只会校验stu_v_4上的约束满足即可。\ninsert into stu_v_2 values(8, &#x27;tom&#x27;);insert into stu_v_2 values(18, &#x27;jerry&#x27;);\n\n\n三、视图的更新和作用视图的更新要使视图可以更新，视图中的行与基础表中的行之间必须存在一一对应的关系。如果视图包含以下任意一项，则该视图不可更新：    1、聚合函数或者窗口函数（SUM(), MIN(), MAX(), COUNT()等）    2、DISTINCT    3、GROUP BY    4、HAVING    5、UNION或者UNION ALL视图的作用简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些经常被使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次都指定全部的条件。安全：数据库可以授权，但是不能授权到数据库特定的行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据。数据独立：视图可以帮助用户屏蔽真实表结构变化带来的影响。\n","tags":["数据库","MySQL"]},{"title":"MySQL学习 ｜ 四、SQL语言中DQL语句的语法","url":"/2023/07/28/MySQL%E5%AD%A6%E4%B9%A0/MySQL%E5%AD%A6%E4%B9%A0%20%EF%BD%9C%20%E5%9B%9B%E3%80%81SQL%E8%AF%AD%E8%A8%80%E4%B8%ADDQL%E8%AF%AD%E5%8F%A5%E7%9A%84%E8%AF%AD%E6%B3%95/","content":"DQL：数据查询语言，用来查询数据库中表里面的数据。\nDQL语法‍‍‍\nSELECT 字段列表 FROM 表名 WHERE 条件 GROUP BY 分组 HAVING 分组后的条件列表 ORDER BY 排序字段列表 LIMIT 分页参数;\n\n数据查询语言的分类：\n&emsp;&emsp;&emsp;&emsp;基本查询‍‍\n&emsp;&emsp;&emsp;&emsp;条件查询（WHERE）\n&emsp;&emsp;&emsp;&emsp;聚合查询（COUNT、MAX、MIN、AVG、SUM）\n&emsp;&emsp;&emsp;&emsp;分组查询（GROUP BY）‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;排序查询（ORDER BY）\n&emsp;&emsp;&emsp;&emsp;分页查询（LIMIT）\n\n\n一、DQL的基础查询1、查询返回多个字段\nSELECT 字段1, 字段2, 字段n FROM 表名;SELECT * FROM 表名;\n\nselect * 可读性以及效率偏低，推荐 select 字段 的方式。\n2、设置别名\nSELECT 字段1 AS [别名1], 字段2 AS [别名2], ... 字段n AS [别名n] FROM 表名;\n\n3、去除重复记录\nSELECT DISTINCT 字段名 FROM 表名；\n\n\n\n二、DQL语句的条件查询‍‍\n\n\n比较运算符\n功能\n\n\n\n&gt;, &gt;&#x3D;\n大于，大于等于\n\n\n&lt;, &lt;&#x3D;\n小于，小于等于\n\n\n&#x3D;\n等于\n\n\n&lt;&gt;, !&#x3D;\n不等于\n\n\nBETWEEN…AND…\n在某个范围内（含最大值和最小值）\n\n\nIN(…)\n在IN之后的列表中\n\n\nLIKE 占位符\n模糊匹配\n\n\nIS NULL\n是NULL\n\n\n\n\n\n\n\n逻辑运算符\n功能\n\n\n\nAND 或 &amp;&amp;\n并且（多个条件同时成立）\n\n\nOR 或 ||\n或者（多个条件满足一个）\n\n\nNOT 或 ！\n非，不是\n\n\n1、查询年龄小于18的员工\nSELECT * FROM 表名 WHERE age &lt; 18;\n\n2、查询年龄等于20的员工‍\nSELECT * FROM 表名 WHERE age = 20;\n\n2、查询年龄不等于20的员工\nSELECT * FROM 表名 WHERE age != 20;SELECT * FROM 表名 WHERE age &lt;&gt; 20;\n\n3、查询没有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is null;\n\n4、查询有年龄的员工信息  \nSELECT * FROM 表名 WHERE age is not null;\n\n6、查询年龄在20到30的员工信息\nSELECT * FROM 表名 WHERE age between 20 and 30;SELECT * FROM 表名 WHERE age &gt;= 20 and and &lt;= 30;\n\n7、查询年龄为20且性别为女的员工信息‍\nSELECT * FROM 表名 WHERE age = 20 and sex = &#x27;女&#x27;;\n\n8、查询年龄为20或者30或者40的员工信息\nSELECT * FROM 表名 WHERE age = 20 or age = 30 or age = 40;SELECT * FROM 表名 WHERE age in (20, 30, 40);\n\n9、查询姓名为两个字的员工(一个下划线代表一个字符)\nSELECT * FROM 表名 WHERE name like &#x27;__&#x27;;\n\n10、查询身份证号最后一位是X的员工信息‍‍‍‍\nSELECT * FROM 表名 WHERE id_card like &#x27;%X&#x27;;\n\n  \n\n三、DQL语句的聚合函数‍‍‍‍‍‍聚合函数作用：将一列数据作为一个整体进行纵向计算。\n注意：所有的null值不进行聚合函数计算。\n1、统计员工数量\nSELECT count(*) FROM 表名;SELECT count(字段名) FROM 表名;\n\n2、统计平均值\nSELECT avg(字段名) FROM 表名;\n\n3、查询最大值  \nSELECT max(字段名) FROM 表名;\n\n4、查询最小值‍\nSELECT min(字段名) FROM 表名;\n\n5、查询某个字段的和\nSELECT sum(字段名)  FROM 表名;\n\n  \n\n四、DQL语句的分组查询‍‍‍‍语法：SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY [HAVING 分组后的过滤条件]‍‍‍‍‍\n注意：\n&emsp;&emsp;&emsp;&emsp;1、分组查询的顺序为where -&gt; 聚合函数 -&gt; having‍‍‍‍‍‍‍‍‍‍‍‍\n&emsp;&emsp;&emsp;&emsp;2、分组之后查询的字段一般为聚合函数和分组字段，查询其他字段无意义。\n&emsp;&emsp;&emsp;&emsp;1、根据性别分组，查询男女员工的数量\nSELECT count(*) FROM 表名 GROUP BY gender;\n\n2、根据性别分组，查询男女员工的平均年龄  \nSELECT avg(age) FROM 表名 GROUP BY gender;\n\n3、查询年龄小于45的员工并且根据工作地址分组，获取员工数量大于3的工作地址\nSELECT count(*) as address_count FROM 表名 WHERE age &lt; 45 GROUP BY work_address HAVING address_count &gt;= 3;\n\n五、DQL语句的排序查询SQL语句中支持多个字段排序，排序方式有两种：ASC代表升序(默认值)，DESC代表降序。‍‍\n1、根据年龄对员工进行升序排列\nSELECT 字段名 FROM 表名 ORDER BY age ASC;\n\n2、根据入职时间进行降序排列  \nSELECT 字段名 FROM 表名 ORDER BY entry_date DESC;\n\n3、根据年龄对员工进行升序排序，年龄相同根据入职时间将序排列‍‍\nSELECT 字段名 FROM 表名 ORDER BY age ASC, entry_date DESC;\n\n  \n\n六、DQL语句的分页查询语法：SELECT 字段名 FROM 表名 LIMIT 起始索引,查询记录数;\n注意：LIMIT为MySQL的方言，不同数据库分页有不同的实现。‍‍\n1、查询第一页的员工数据，每页展示10条\nSELECT * FROM LIMIT 0,10;\n\n2、查询第二页的员工数据，每页展示10条  \nSELECT * FROM LIMIT 10,10;\n\n  \n\n七、DQL语句的执行顺序‍‍‍‍FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT\n","tags":["数据库","MySQL"]},{"title":"Ubuntu 22.04上安装Nginx步骤","url":"/2025/11/13/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85Nginx%E6%AD%A5%E9%AA%A4/","content":"使用apt安装nginx使用命令 apt list -a nginx 查看有哪些版本可以安装。如果不想指定版本，可以执行 sudo apt install nginx -y 直接安装最新的版本（本文以此为例）。\n安装 🚀\n1、安装nginx\nsudo apt install nginx -y\n\n2、执行以下命令检查 Nginx 是否成功安装\nnginx -v\n\n3、成功会输出版本号\nnginx version: nginx/1.29.3\n\n启动和设置开机自启 🍃\n1、启动 Nginx\nsudo systemctl start nginx\n\n2、设置开机自启\nsudo systemctl enable nginx\n\n3、查看运行状态\nsudo systemctl status nginx\n\n如果看到输出中包含：Active: active (running) 说明 Nginx 已经启动成功。\n配置防火墙 🧱sudo ufw allow &#x27;Nginx Full&#x27;sudo ufw reload\n使用 sudo ufw status 查看规则是否生效。\nNginx 默认文件结构说明 📖\n\n\n目录&#x2F;文件\n说明\n\n\n\n/etc/nginx/nginx.conf\n主配置文件\n\n\n/etc/nginx/sites-available/\n存放虚拟主机配置文件\n\n\n/etc/nginx/sites-enabled/\n指向启用的虚拟主机配置（通过软链接）\n\n\n/var/www/html/\n默认网页目录（index.html 放这里）\n\n\n/var/log/nginx/access.log\n访问日志\n\n\n/var/log/nginx/error.log\n错误日志\n\n\n配置HTTPS（免费证书）✅1️⃣ 安装 Certbot（Let’s Encrypt 工具）：\nsudo apt install certbot python3-certbot-nginx -y\n\n2️⃣ 获取证书：\nsudo certbot --nginx -d blog.example.com\nCertbot 会自动：\n\n验证域名；\n生成 SSL 证书；\n修改 Nginx 配置文件；\n自动配置 HTTPS。\n\n3️⃣ 自动续期检查：\nsudo certbot renew --dry-run\n\n常用命令速查 👀\n\n\n操作\n命令\n\n\n\n启动 Nginx\nsudo systemctl start nginx\n\n\n停止 Nginx\nsudo systemctl stop nginx\n\n\n重启 Nginx\nsudo systemctl restart nginx\n\n\n平滑加载配置\nsudo systemctl reload nginx\n\n\n检查配置文件\nsudo nginx -t\n\n\n查看日志\nsudo tail -f /var/log/nginx/access.log\n\n\n","tags":["中间件","Nginx"]},{"title":"Ubuntu 22.04 新装的系统如何修改root用户密码","url":"/2025/11/18/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ubuntu%E6%96%B0%E8%A3%85%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9root%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/","content":"✅ 使用 sudo 修改 root 密码Ubuntu 默认给普通用户配置了 sudo，执行下面命令即可：\nsudo passwd root\n系统首先会提示输出当前用户的密码，输入当前用户密码后会提示你输入两次root用户的新密码。\n🔐 启用 root SSH 登录启用 root SSH 登录\nsudo vi /etc/ssh/sshd_config\n找到 PermitRootLogin prohibit-password 这行配置，改为 PermitRootLogin yes，然后重启SSH服务 sudo systemctl restart ssh。\n","tags":["操作系统","Ubuntu"]},{"title":"Ubuntu磁盘分区和挂载步骤","url":"/2025/11/18/%E4%B8%AD%E9%97%B4%E4%BB%B6/Ubuntu%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%E5%92%8C%E6%8C%82%E8%BD%BD%E6%AD%A5%E9%AA%A4/","content":"一、预检查（确认 LVM 空闲空间与卷组名）先看看当前 LVM 信息，确认可以划出足够的容量：\nsudo pvs        # 查看物理卷（PV）sudo vgs        # 查看卷组（VG）及可用空间（VG Free）sudo lvs        # 查看现有逻辑卷（LV）\n\n期望看到 ubuntu-vg（或类似名）有大约剩余 ~9.9T 的空闲空间（VG Free）。示例里面要关注的字段：VG 名称（这里例子是 ubuntu-vg）与 VG Free（必须 &gt;&#x3D; 9T）。\n二、创建逻辑卷（9T）将 9T 从卷组里分配到新的 LV（这里 LV 名称用 minio，可以自定义）：\nsudo lvcreate -n minio -L 9T ubuntu-vg\n说明：\n\n-n minio 是 LV 名称 &#x2F;dev&#x2F;ubuntu-vg&#x2F;minio\n-L 9T 分配 9 TB（注意 T 为 Tebibyte 还是 TB，LVM 默认是 TiB）\nubuntu-vg 是示例卷组名，若你 vgs 看到不同名请替换为真实的 VG 名称\n\n创建成功后确认：\nsudo lvs -o+devices# 或sudo lvdisplay /dev/ubuntu-vg/minio\n\n三、格式化为 XFS（推荐 XFS 用于大文件&#x2F;对象存储）sudo mkfs.xfs -f /dev/ubuntu-vg/minio\n说明：\n\n-f 强制格式化（如果是新创建 LV 通常不必要，但保险写上）\nXFS 对大容量&#x2F;并发写入表现好，MinIO 推荐 XFS（或 ext4 也行）\n\n四、创建挂载点并挂载（临时挂载验证）创建目录并挂载：\nsudo mkdir -p /datasudo mount /dev/ubuntu-vg/minio /data\n检查挂载：\ndf -hT /data# 或lsblk -f\n应看到 &#x2F;dev&#x2F;mapper&#x2F;ubuntu–vg-minio 已挂载到 &#x2F;data，文件系统类型 xfs，容量约 9T。\n五、设置合适的挂载选项并写入 &#x2F;etc&#x2F;fstab（自动挂载且优化）建议使用 XFS 常用选项：noatime,nodiratime,attr2,inode64。把设备用 UUID 写入 fstab 更稳妥：先获取 &#x2F;dev 的 UUID：\nsudo blkid /dev/ubuntu-vg/minio\n复制 UUID&#x3D;”…” 部分，然后编辑 &#x2F;etc&#x2F;fstab（用 root 权限）\nsudo cp /etc/fstab /etc/fstab.bak    # 备份 fstabsudo vi /etc/fstab\n添加一行（用你上一步得到的 UUID:71800ad3-9c32-45f2-8915-92888db5b1fe 替换 ；如果不想用 UUID，也可用设备路径 &#x2F;dev&#x2F;ubuntu-vg&#x2F;minio）：\nUUID=&lt;YOUR-UUID&gt;  /data  xfs  defaults,noatime,nodiratime,attr2,inode64  0  2\n保存后测试 fstab 无误并重新挂载（先卸载再 mount -a）：\nsudo umount /datasudo mount -amount | grep &#x27; /data &#x27;\n如果 mount -a 没报错，说明写入成功。\n六、设定目录权限（给 MinIO 或其他服务用）sudo useradd -r -s /sbin/nologin minio || truesudo chown -R minio:minio /datasudo chmod 750 /data\n\n说明：如果已经有 minio 用户就不需要创建 useradd（|| true 保证已存在不会报错）。\n\n七、验证空间与权限df -h /datasudo ls -ld /datasudo ls -la /datasudo getfattr -d -m - /data   # optional, 查看 xfs 属性\n\n八、如果将来想扩容或缩小\n扩容：如果 VG 还有空闲空间，可用 lvextend -L +XG &#x2F;dev&#x2F;ubuntu-vg&#x2F;minio 然后 xfs_growfs &#x2F;data 在线扩容（XFS 支持在线扩展）。\n缩小：XFS 不支持在线缩小，缩小比较复杂，需备份、重建文件系统或转换为 ext4 并小心操作。\n\n示例扩容命令：\n# 假设还剩余 1T 空间，扩展 1Tsudo lvextend -L +1T /dev/ubuntu-vg/miniosudo xfs_growfs /datadf -h /data","tags":["操作系统","Ubuntu"]},{"title":"做饭 ｜ 柠檬风爪制作","url":"/2023/11/09/%E5%81%9A%E9%A5%AD/%E5%87%A4%E7%88%AA%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B/","content":"鸡爪处理过程1、清水浸泡解冻 3H 去腥，水没过鸡爪，中间换水两到三次。\n2、清水 15 斤、葱段 100g、姜片 60g、盐 80g，加入去腥料包（配方在下面）大火烧开后小火煮 10min。\n3、10min 后转大火烧开下入鸡爪（开锅状态下下鸡爪），加入白醋（九度）40g，白酒 50g，汤开后转小火煮 5min，途中打掉浮沫。\n4、盖锅盖闷 5min，捞出先用凉水浸泡，再用冰水浸泡，保证 Q 弹。\n5、按照口味将调味料倒入鸡爪中，抓拌 5min 浸泡 5min，重复 3 次。密封冷藏 1 小时。\n口味1、柠檬百香果泡爪（3 斤熟鸡爪）味极鲜 60g、一品鲜 60g、白醋（九度）120g、泡椒水 210g、辣鲜露 45g、白糖 180g、鸡精味精各 15g、苹果醋 30g、蚝油 45g、泡椒 50g、百香果酱 90g、纯净水 180g、洋葱丝 50g、葱姜丝 30g、青椒圈 18g、小米辣 60g、柠檬片 3 片（去籽后挤出汁丢入）、幺麻子红油 150g。\n去腥料包配方（10 斤鸡爪）八角 8g、花椒 8g、香液 6g、桂皮 4g、草果 4g（拍碎不去籽）、白芷 4g。\n","tags":["做饭"]},{"title":"Mac上使用cwebp压缩图片","url":"/2025/11/12/%E5%B0%8F%E5%B7%A5%E5%85%B7/Mac%E4%B8%8A%E4%BD%BF%E7%94%A8cwebp%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/","content":"\ncwebp 是 WebP 图像格式的命令行工具，它允许你将常见的图像格式（如 PNG、JPEG）转换为 WebP 格式，这样可以减少图像的文件大小，同时保持较高的图像质量。\n\n下载cwebp使用brew命令下载webp\nbrew install webp\n安装完成以后，使用以下命令验证是否安装成功，安装成功以后会输出版本号\ncwebp -version\n\ncwebp 使用说明cwebp 用于将图像转换为 WebP 格式，支持多种输入格式，如 PNG、JPEG、TIFF、GIF 等。转换后的 WebP 图像通常具有较小的文件大小，同时保持较高的图像质量。\n基本语法cwebp [input options] -o [output file] [input file]\n\n常见参数说明\n-q (质量)，用于设置输出图像的质量。质量值从 0 到 100，数字越大，图像质量越高，文件大小也越大，默认值是 75。\ncwebp -q 80 input.jpg -o output.webp\n\n-lossless (无损压缩)，启用无损压缩（即保持原图质量），这对于 PNG 到 WebP 的转换特别有用，尽管输出文件可能较大。\ncwebp -lossless input.png -o output.webp\n\n-resize (调整图像尺寸)，用于调整输出 WebP 图像的尺寸。格式：-resize width height，只需设置一个参数即可自动按比例调整。\ncwebp -resize 800 600 input.jpg -o output.webp\n\n-alpha_q (Alpha 通道质量)，控制透明度（Alpha 通道）的压缩质量。0 表示最小压缩（最好的透明度质量），100 表示最大压缩（最差的透明度质量）。\ncwebp -alpha_q 90 input.png -o output.webp\n\n-lossless，启用无损压缩。这将保留原始图像的质量，不会丢失任何细节。\ncwebp -lossless input.png -o output.webp\n\n-m (压缩方法)，设置压缩方法。m 参数用于控制压缩的速度和压缩比，取值范围是 0 到 6。0 表示最快，6 表示压缩最优，但速度最慢。\ncwebp -m 6 input.jpg -o output.webp\n\n-alpha (透明度处理)，控制 WebP 图像中透明区域的处理方式。适用于透明图像（通常为 PNG）。\ncwebp -alpha input.png -o output.webp\n\n-crop (裁剪图像)，裁剪图像的一部分，格式：-crop x y width height。\ncwebp -crop 0 0 300 200 input.jpg -o output.webp\n\n-v (详细模式)，启用详细模式，输出更详细的信息，适合调试使用。\ncwebp -v input.jpg -o output.webp\n\n-preset (预设值)，提供不同的质量&#x2F;压缩设置，适合不同的用途，如 photo、picture、drawing、icon 和 text。\ncwebp -preset photo input.jpg -o output.webp\n\n"},{"title":"脚本/Jar包启动、停止、重启脚本","url":"/2024/01/31/%E8%84%9A%E6%9C%AC/Jar%E5%8C%85%E5%90%AF%E5%8A%A8%E3%80%81%E5%81%9C%E6%AD%A2%E3%80%81%E9%87%8D%E5%90%AF%E8%84%9A%E6%9C%AC/","content":"#APP_ID MUST BE UNIQUE.APP_ID=&quot;DATA_GENERATE&quot;JAR_FILE_NAME=&quot;data_generate.jar&quot;SERVER_PORT=&quot;10002&quot;JAVA=/home/weblogic/java-se-8u40-ri/bin/javaecho JAVA_HOME=$JAVA_HOME######set properties to override yaml#####ISA_SYS_PARAM=&quot;--spring.profiles.active=prod&quot;ISA_SYS_PARAM=&quot;$&#123;ISA_SYS_PARAM&#125; --server.port=$&#123;SERVER_PORT&#125;&quot;ISA_SYS_PARAM=&quot;$&#123;ISA_SYS_PARAM&#125; --logging.loglevel=INFO&quot;######JVM Options######JAVA_OPT=&quot;-Xmx2g  -Xms1g -XX:MaxPermSize=128m &quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:HeapDumpPath=./jvmdump/$&#123;SERVER_PORT&#125;_dumpfile.hprof &quot;JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:+HeapDumpOnOutOfMemoryError &quot;#ONE JAR MORE INSTANCEPID=$(ps -ef|grep DPGM_ID=$&#123;APP_ID&#125; | grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;)#ONE JAR ONE INSTANCE#PID=$(fuser $&#123;JAR_FILE_NAME&#125; 2&gt;/dev/null | xargs echo)start()&#123;  if ! kill -0 $&#123;PID&#125; 2&gt;/dev/null ;then  \techo &quot;$&#123;APP_ID&#125; is starting! File is $&#123;JAR_FILE_NAME&#125;&quot;    nohup $&#123;JAVA&#125; -jar $&#123;JAVA_OPT&#125; -DPGM_ID=$&#123;APP_ID&#125; -DAPP_NAME=$&#123;APP_ID&#125; $&#123;JAR_FILE_NAME&#125; $&#123;ISA_SYS_PARAM&#125; &amp;  else    echo &quot;Failed to start &#x27;$&#123;APP_ID&#125;&#x27;,because it is running (pid:$&#123;PID&#125;).&quot;  fi&#125;stop()&#123;\t if  ! kill -0 $&#123;PID&#125; 2&gt;/dev/null; then\t     echo &quot;Failed to stop &#x27;$&#123;APP_ID&#125;&#x27;,It is not running.&quot;\t  else\t    kill $&#123;PID&#125;\t     echo &quot;kill $&#123;PID&#125;,$&#123;APP_ID&#125; is killing.&quot;\t    a=0\t    until  ! kill -0 $&#123;PID&#125; 2&gt;/dev/null\t    do\t      if [ $a -lt 10 ] ;then\t        echo &quot;Stopping &#x27;$&#123;APP_ID&#125;&#x27;, Recheck 3 seconds later.&quot;\t        sleep 3\t      else\t        break\t      fi\t      a=`expr $a + 1`\t    done\t  fi\t  if  kill -0 $&#123;PID&#125; 2&gt;/dev/null  ;then\t     echo &quot;Fail to kill &#x27;$&#123;APP_ID&#125;&#x27; in 30 seconds.&quot;\t     kill -9 $&#123;PID&#125;\t     echo &quot;kill -9 $&#123;PID&#125;, $&#123;APP_ID&#125; is killed&quot;\t  fi\t  sleep 3\t  if  ! kill -0 $&#123;PID&#125; 2&gt;/dev/null  ;then\t    echo &quot;&#x27;$&#123;APP_ID&#125;&#x27; has been stoped.&quot;\t  else\t    echo &quot;&#x27;$&#123;APP_ID&#125;&#x27; fail to stop.&quot;\t  fi&#125;restart()&#123;    stop    start&#125;status()&#123;  if kill -0 $&#123;PID&#125; 2&gt;/dev/null ;then    echo &quot;$&#123;APP_ID&#125; (pid:$&#123;PID&#125;) is running.&quot;  else    echo &quot;$&#123;APP_ID&#125; is not running.&quot;  fi&#125;case $1 in  start)    start;;  stop)    stop;;  restart)    restart;;  fstop)    fstop;;  status)    status;;  *)    echo &quot;Usage: $0 start|stop|status&quot;esac"},{"title":"工作笔记 ｜ 一个简单的在linux系统中启动jar包的命令","url":"/2023/08/29/%E8%84%9A%E6%9C%AC/%E5%B7%A5%E4%BD%9C%E7%AC%94%E8%AE%B0%20%EF%BD%9C%20%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%90%AF%E5%8A%A8jar%E5%8C%85%E7%9A%84%E5%91%BD%E4%BB%A4/","content":"\n当有多个项目时，挨个重启总是感觉很麻烦，所以下面这个脚本诞生了，直接替换app列表中的参数为启动的jar包名即可挨个启动项目。启动前会判断当前是否存在运行该jar包的进程，存在的话先杀死进程，再执行启动命令。日志输出可以提出来写一个公共方法，启动模版也是（后面有时间的话可以考虑可以改一下）。 \n\n#!/bin/bashsource ~/.bash_profilesource /etc/profileecho &quot;#####################  &quot;`date &#x27;+%Y-%m-%d %H:%M&#x27;`&quot; ########################&quot; &gt;&gt; run.log###JVM参数JAVA_OPTIONS=&quot;-Xms1024m -Xmx1024m -Xmn256m -Xss256k -XX:MetaspaceSize=64m -XX:MaxMetaspaceSize=64m&quot;### JMX参数JMX_OPTIONS=&quot;-Djava.rmi.server.hostname=127.0.0.1 -Dcom.sun.management.jmxremote.port=8098 -Dcom.sun.management.jmxremote.rmi.port=8098 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false&quot;# 服务列表app=(linze_healthcheck_java_pc-0.0.1-SNAPSHOT)for i in $&#123;app[*]&#125;;do        # 停止旧项目    ps -ef | grep $i.jar | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9    echo &#x27;停止项目完成!!!&#x27;\tpid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t# 判断当前服务是否启动\tif [ &quot;$pid&quot; != &quot;&quot; ]; then\t\techo &#x27;当前服务[ &#x27;$i&#x27; ]已经是运行状态,端口号：&#x27;$pid &gt;&gt; run.log\t\t# 杀死进程重新启动\t\techo &#x27;杀死旧进程:&#x27;$pid&#x27;, 准备重新启动&#x27; &gt;&gt; run.log\t\tkill -9 $pid\t\t# 休息3s\t\tsleep 3\t\tfor name in `find . -name $i.jar`;do\t\t\tnohup java -jar $JAVA_OPTIONS $JMX_OPTIONS $name &gt; /dev/null 2&gt;&amp;1 &amp;\t\t\tsleep 3\t\t\tppid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t\t\tif [ &quot;$ppid&quot; != &quot;&quot; ]; then\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]重启完成！&#x27; &gt;&gt; run.log\t\t\telse\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]重启失败！&#x27; &gt;&gt; run.log\t\t\tfi\t\tdone\telse\t\tfor name in `find . -name $i.jar`;do\t\t\techo &#x27;当前启动服务[ &#x27;$i&#x27; ], jar位置:&#x27;$name &gt;&gt; run.log\t\t\tnohup java -jar $JAVA_OPTIONS $JMX_OPTIONS $name &gt; /dev/null 2&gt;&amp;1 &amp;\t\t\tsleep 3\t\t\tppid=`ps -ef | grep $i.jar| grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`\t\t\tif [ &quot;$ppid&quot; != &quot;&quot; ]; then\t\t        echo &#x27;服务[ &#x27;$i&#x27; ]启动完成！&#x27; &gt;&gt; run.log\t\t\telse\t\t\t\techo &#x27;服务[ &#x27;$i&#x27; ]启动失败！&#x27; &gt;&gt; run.log\t\t\tfi\t\tdone\tfidone","tags":["Shell"]}]